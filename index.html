<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tobogán Decomiso 3D</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #0b1220; }
    #ui-panel {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .btn {
      padding: 10px 14px;
      border: none;
      border-radius: 6px;
      background: #1e40af;
      color: #e2e8f0;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    .btn:hover { background: #1d4ed8; }
    .badge {
      padding: 8px 12px;
      border-radius: 6px;
      background: #0f172a;
      color: #a5b4fc;
      font-weight: 700;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      font-size: 13px;
    }
  </style>
  <script>
    // Desregistrar cualquier Service Worker viejo
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs => {
        regs.forEach(reg => reg.unregister());
      });
    }
  </script>
</head>
<body>
  <div id="ui-panel">
    <button class="btn" id="btn-toggle-walls">Ocultar paneles</button>
    <button class="btn" data-view="iso">Vista isométrica</button>
    <button class="btn" data-view="top">Vista superior</button>
    <button class="btn" data-view="wall2">Vista pared 2</button>
    <button class="btn" data-view="wall4">Vista pared 4</button>
    <div class="badge" id="version-badge">v0.0.0</div>
  </div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
    import { RoundedBoxGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/geometries/RoundedBoxGeometry.js';
    
    const APP_VERSION = 'v0.2.1';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1220);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    const initialHeight = window.innerHeight - 40;
    renderer.setSize(window.innerWidth, initialHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / initialHeight, 0.1, 10000);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(2000, 2500, 1200);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    scene.add(dir);

    // Constantes de sala y bin
    const ROOM_W = 4000;
    const ROOM_L = 4000;
    const ROOM_H = 4000;
    const WALL_THK = 115;
    const BIN_W = 1200, BIN_L = 1000, BIN_H = 900;
    const BIN_THK = 35;
    const BIN_POS_X = ROOM_W/2 - WALL_THK - BIN_W/2 - 100;
    const BIN_POS_Z = ROOM_L/2 - WALL_THK - BIN_L/2 - 700;

    // Suelo
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(5000, 5000),
      new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.9, metalness: 0 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    // Paredes PIR
    const wallGroup = new THREE.Group();
    const wallMat = new THREE.MeshPhysicalMaterial({
      color: 0x9fb8d6,
      roughness: 0.35,
      metalness: 0.05,
      transparent: true,
      opacity: 0.35,
      transmission: 0.25,
      thickness: 1.0
    });

    function buildWall(width, height, depth, pos, rotY) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), wallMat);
      wall.position.copy(pos);
      wall.rotation.y = rotY;
      wall.castShadow = false;
      wall.receiveShadow = true;
      wallGroup.add(wall);
    }

    const halfW = ROOM_W / 2 - WALL_THK / 2;
    const halfL = ROOM_L / 2 - WALL_THK / 2;
    const wallHeight = ROOM_H - 100;
    buildWall(ROOM_W, wallHeight, WALL_THK, new THREE.Vector3(0, wallHeight/2, -halfL), 0);
    buildWall(ROOM_W, wallHeight, WALL_THK, new THREE.Vector3(0, wallHeight/2, halfL), 0);
    buildWall(ROOM_L, wallHeight, WALL_THK, new THREE.Vector3(-halfW, wallHeight/2, 0), Math.PI/2);
    buildWall(ROOM_L, wallHeight, WALL_THK, new THREE.Vector3(halfW, wallHeight/2, 0), Math.PI/2);
    scene.add(wallGroup);

    // Etiquetas 1-4
    function makeLabel(text) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,size,size);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 140px Segoe UI';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(text, size/2, size/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(600, 600, 1);
      return spr;
    }
    const labelLeft = makeLabel('1'); labelLeft.position.set(-ROOM_W/2 + WALL_THK + 20, ROOM_H/2, 0);
    const labelRight = makeLabel('2'); labelRight.position.set(ROOM_W/2 - WALL_THK - 20, ROOM_H/2, 0);
    const labelBack = makeLabel('3'); labelBack.position.set(0, ROOM_H/2, -ROOM_L/2 + WALL_THK + 20);
    const labelFront = makeLabel('4'); labelFront.position.set(0, ROOM_H/2, ROOM_L/2 - WALL_THK - 20);
    const labels = [labelLeft, labelRight, labelBack, labelFront];
    scene.add(...labels);

    // Bin placeholder
    let binPlaceholder;

    function createBinPlaceholder() {
      const g = new THREE.Group();
      const bodyColor = 0x1f66d8;
      const matBody = new THREE.MeshStandardMaterial({
        color: bodyColor,
        roughness: 0.55,
        metalness: 0.05,
        transparent: true,
        opacity: 0.95,
        transmission: 0.03
      });
      const matDetail = new THREE.MeshStandardMaterial({ color: 0x104caa, roughness: 0.6, metalness: 0.05 });
      const overlap = 10;

      const base = new THREE.Mesh(new RoundedBoxGeometry(BIN_W, BIN_THK, BIN_L, 4, BIN_THK*0.5), matBody);
      base.position.y = BIN_THK/2;
      base.castShadow = true; base.receiveShadow = true;
      g.add(base);

      const wallSideGeom = new RoundedBoxGeometry(BIN_THK, BIN_H, BIN_L - 2*BIN_THK + 2*overlap, 4, BIN_THK*0.45);
      const wallFrontGeom = new RoundedBoxGeometry(BIN_W - 2*BIN_THK + 2*overlap, BIN_H, BIN_THK, 4, BIN_THK*0.45);

      const wallL = new THREE.Mesh(wallSideGeom, matBody);
      wallL.position.set(-BIN_W/2 + BIN_THK/2, BIN_THK/2 + BIN_H/2, 0);
      const wallR = wallL.clone(); wallR.position.x = BIN_W/2 - BIN_THK/2;
      const wallF = new THREE.Mesh(wallFrontGeom, matBody);
      wallF.position.set(0, BIN_THK/2 + BIN_H/2, BIN_L/2 - BIN_THK/2);
      const wallB = wallF.clone(); wallB.position.z = -BIN_L/2 + BIN_THK/2;
      [wallL, wallR, wallF, wallB].forEach(w => { w.castShadow = true; w.receiveShadow = true; g.add(w); });

      const cornerGeom = new RoundedBoxGeometry(BIN_THK + overlap, BIN_H, BIN_THK + overlap, 4, BIN_THK*0.35);
      const corners = [
        { x:-BIN_W/2 + BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x:-BIN_W/2 + BIN_THK/2, z: BIN_L/2 - BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z:-BIN_L/2 + BIN_THK/2 },
        { x: BIN_W/2 - BIN_THK/2, z: BIN_L/2 - BIN_THK/2 }
      ];
      corners.forEach(c => {
        const corner = new THREE.Mesh(cornerGeom, matBody);
        corner.position.set(c.x, BIN_THK/2 + BIN_H/2, c.z);
        corner.castShadow = true; corner.receiveShadow = true;
        g.add(corner);
      });

      const footGeom = new THREE.BoxGeometry(BIN_W/3 - 40, 120, BIN_L/2);
      [ -BIN_W/3, 0, BIN_W/3 ].forEach(x => {
        const foot = new THREE.Mesh(footGeom, matDetail);
        foot.position.set(x, 60, 0);
        foot.castShadow = true; foot.receiveShadow = true;
        g.add(foot);
      });

      const overhang = 350;
      const clothWidth = BIN_W + overhang*1.2;
      const clothDepth = BIN_L + overhang*1.2;
      const bagMesh = createClothMesh(clothWidth, clothDepth, overhang);
      g.add(bagMesh);

      g.position.set(BIN_POS_X, 0, BIN_POS_Z);
      return g;
    }

    // Cloth sim
    const cloth = { resX: 30, resY: 30, points: [], prev: [], pinned: [], geom: null, mesh: null, running: true };
    const clothWidthCache = { dx: 0, dz: 0 };

    function idx(u, v) { return v * cloth.resX + u; }

    function createClothMesh(width, height, overhang) {
      const dx = width / (cloth.resX - 1);
      const dz = height / (cloth.resY - 1);
      clothWidthCache.dx = dx;
      clothWidthCache.dz = dz;
      cloth.points = new Array(cloth.resX * cloth.resY);
      cloth.prev = new Array(cloth.resX * cloth.resY);
      cloth.pinned = new Array(cloth.resX * cloth.resY).fill(false);

      const startY = BIN_H + overhang + 100;
      for (let v = 0; v < cloth.resY; v++) {
        for (let u = 0; u < cloth.resX; u++) {
          const x = -width/2 + u * dx;
          const z = -height/2 + v * dz;
          const y = startY - v * 5;
          const p = new THREE.Vector3(x, y, z);
          cloth.points[idx(u,v)] = p.clone();
          cloth.prev[idx(u,v)] = p.clone();
        }
      }

      cloth.pinned[idx(0,0)] = true;
      cloth.pinned[idx(cloth.resX-1,0)] = true;
      cloth.pinned[idx(0,cloth.resY-1)] = true;
      cloth.pinned[idx(cloth.resX-1,cloth.resY-1)] = true;

      cloth.geom = new THREE.BufferGeometry();
      const positions = new Float32Array(cloth.points.length * 3);
      cloth.geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const indices = [];
      for (let v=0; v<cloth.resY-1; v++) {
        for (let u=0; u<cloth.resX-1; u++) {
          const a = idx(u, v);
          const b = idx(u+1, v);
          const c = idx(u, v+1);
          const d = idx(u+1, v+1);
          indices.push(a, c, b, b, c, d);
        }
      }
      cloth.geom.setIndex(indices);
      cloth.geom.computeVertexNormals();

      const bagMat = new THREE.MeshPhysicalMaterial({
        color: 0xe8f4ff,
        roughness: 0.75,
        metalness: 0,
        transparent: true,
        opacity: 0.42,
        transmission: 0.65,
        thickness: 1.5,
        ior: 1.02,
        side: THREE.DoubleSide
      });
      cloth.mesh = new THREE.Mesh(cloth.geom, bagMat);
      cloth.mesh.castShadow = false;
      cloth.mesh.receiveShadow = false;
      return cloth.mesh;
    }

    function satisfyConstraints(iterations, rest) {
      for (let it=0; it<iterations; it++) {
        for (let v=0; v<cloth.resY; v++) {
          for (let u=0; u<cloth.resX; u++) {
            const i = idx(u,v);
            const p = cloth.points[i];
            if (u < cloth.resX-1) {
              const j = idx(u+1,v); project(p, cloth.points[j], rest.dx);
            }
            if (v < cloth.resY-1) {
              const j = idx(u,v+1); project(p, cloth.points[j], rest.dz);
            }
          }
        }
      }
    }

    function project(p1, p2, restLen) {
      const delta = new THREE.Vector3().subVectors(p2, p1);
      const dist = delta.length();
      if (!dist) return;
      const diff = (dist - restLen) / dist;
      const corr = delta.multiplyScalar(0.5 * diff);
      p1.add(corr);
      p2.sub(corr);
    }

    function applyForces(dt) {
      const gravity = new THREE.Vector3(0, -980, 0);
      const damp = 0.995;
      const dt2 = dt*dt;
      for (let i=0; i<cloth.points.length; i++) {
        if (cloth.pinned[i]) continue;
        const p = cloth.points[i];
        const prev = cloth.prev[i];
        const vel = new THREE.Vector3().subVectors(p, prev).multiplyScalar(damp);
        const next = new THREE.Vector3().addVectors(p, vel).addScaledVector(gravity, dt2);
        cloth.prev[i] = p.clone();
        cloth.points[i] = next;
      }
    }

    function collideBin() {
      const innerX = BIN_W/2 - BIN_THK * 0.6;
      const innerZ = BIN_L/2 - BIN_THK * 0.6;
      const innerY = BIN_H - 5;
      const outerX = BIN_W/2 + 40;
      const outerZ = BIN_L/2 + 40;
      const cuffY = BIN_H + 400;

      for (let i=0; i<cloth.points.length; i++) {
        const p = cloth.points[i];
        const insideFootprint = Math.abs(p.x) <= innerX && Math.abs(p.z) <= innerZ;
        if (insideFootprint && p.y < innerY) {
          p.x = Math.max(-innerX, Math.min(innerX, p.x));
          p.z = Math.max(-innerZ, Math.min(innerZ, p.z));
          p.y = Math.max(BIN_THK * 0.6, p.y);
        } else {
          p.x = Math.max(-outerX, Math.min(outerX, p.x));
          p.z = Math.max(-outerZ, Math.min(outerZ, p.z));
          p.y = Math.min(cuffY, p.y);
          if (p.y < BIN_H - 40) p.y = BIN_H - 40;
        }
      }
    }

    function updateGeometry() {
      const pos = cloth.geom.getAttribute('position');
      for (let i=0; i<cloth.points.length; i++) {
        const p = cloth.points[i];
        pos.setXYZ(i, p.x, p.y, p.z);
      }
      pos.needsUpdate = true;
      cloth.geom.computeVertexNormals();
    }

    function stepCloth(dt, rest) {
      if (!cloth.running) return;
      applyForces(dt);
      satisfyConstraints(10, rest);
      collideBin();
      updateGeometry();
    }

    binPlaceholder = createBinPlaceholder();
    scene.add(binPlaceholder);

    // Vistas rápidas
    const views = {
      iso: { pos: new THREE.Vector3(1800, 1800, 2000), target: new THREE.Vector3(0, 600, 0) },
      top: { pos: new THREE.Vector3(0, 3000, 0), target: new THREE.Vector3(0, 0, 0) },
      wall2: { pos: new THREE.Vector3(2200, 800, 0), target: new THREE.Vector3(0, 600, 0) },
      wall4: { pos: new THREE.Vector3(0, 800, 2200), target: new THREE.Vector3(0, 600, 0) }
    };

    function setView(key) {
      const v = views[key];
      if (!v) return;
      camera.position.copy(v.pos);
      controls.target.copy(v.target);
      controls.update();
    }

    // Vista inicial
    setView('iso');

    // Mostrar versión
    const versionBadge = document.getElementById('version-badge');
    if (versionBadge) versionBadge.textContent = APP_VERSION;

    // Toggle paredes
    let wallsVisible = true;
    document.getElementById('btn-toggle-walls').addEventListener('click', ()=>{
      wallsVisible = !wallsVisible;
      wallGroup.visible = wallsVisible;
      labels.forEach(l=> l.visible = wallsVisible);
      document.getElementById('btn-toggle-walls').textContent = wallsVisible ? 'Ocultar paneles' : 'Mostrar paneles';
    });

    // Botones de vista
    document.querySelectorAll('[data-view]').forEach(btn => {
      btn.addEventListener('click', () => setView(btn.dataset.view));
    });

    // Cargar GLB si existe
    (function cargarBinGLB() {
      const loader = new GLTFLoader();
      loader.load('bin_model.glb', gltf => {
        if (binPlaceholder) scene.remove(binPlaceholder);
        cloth.running = false;
        const obj = gltf.scene;
        obj.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
        obj.position.set(BIN_POS_X, 0, BIN_POS_Z);
        scene.add(obj);
      }, undefined, () => {});
    })();

    let last = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;

      if (cloth.geom) {
        const rest = { dx: clothWidthCache.dx, dz: clothWidthCache.dz };
        stepCloth(dt, rest);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      const h = window.innerHeight - 40;
      camera.aspect = window.innerWidth / h;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, h);
    });
  </script>
</body>
</html>
